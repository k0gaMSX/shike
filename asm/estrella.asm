
;NOMBRE: A_ESTRELLA
;OBJETIVO: ENCONTRAR EL CAMINO DE MENOR COSTO ENTRE LA POSICION DE UN
;          PERSONAJE Y UN PUNTO.
;ENTRADA: IX -> PUNTERO AL PERSONAJE
;         HL -> COORDENADA Y OBJETIVO
;         DE -> COORDENADA X OBJETIVO
;SALIDA:  HL -> PUNTERO AL BUFFER CON LOS OPERADORES
;         B  -> NUMERO DE OPERADORES EN EL BUFFER WAY_A_EST.
;         A  -> SERA  0  SI SE HA ENCONTRADO UN CAMINO
;            -> SERA -1  SI NO SE HA ENCONTRADO UN CAMINO



A_ESTRELLA:	CALL	INIT_A_EST	;EL CASO SIN SOLUCION NO FUNCIONA
;                                       ;(EL CUADRO OBJETIVO NO ES ACCESIBLE)
;                                       ;ADEMAS SE DEBE DEVOLVER EL COSTE DEL
;                                       ;CAMINO OPTIMO.


A_EST_B	CALL	GET_BEST_A
	CP	1
	JR	Z,A_EST_SOL
	CP	-1
	RET	Z
	CALL	GEN_HIJOS
	JR	A_EST_B


A_EST_SOL	LD	HL,WAY_A_EST+256
	LD	B,1
	LD	A,$80
	LD	(HL),A

A_EST_B1_SOL	
	LD	A,(IY+STREST_OPERA)
	DEC	HL
	LD	(HL),A

	LD	E,(IY+STREST_PADRE)
	LD	D,(IY+STREST_PADRE+1)
	XOR	A
	CP	E
	JR	NZ,A_EST_B1_SOL1
	CP	D
	JR	Z,A_EST_B2

A_EST_B1_SOL1	PUSH	DE
	POP	IY
	INC	B
	JR	A_EST_B1_SOL


A_EST_B2	INC	HL
	DEC	B
	XOR	A
	RET

WAY_A_EST:	DS	255
A_EST_XF:	DW	32
A_EST_YF:	DW	32
NUM_NODOS	DB	0
TAM_NODOS	DW	0
INSERT:		DS	STRUCTESTADO


;NOMBRE: INIT_A_EST
;OBJETIVO: SE ENCARGA DE INICIALIZAR LAS ESTRUCTURASD E DATOS NECESARIAS.
;ENTRADA: DE -> COORDENADA X FINAL
;         HL -> COORDENADA Y FINAL
;         IX -> PUNTERO AL PERSONAJE QUE SE QUIERE MOVER


INIT_A_EST:	LD	(A_EST_XF),DE
	LD	(A_EST_YF),HL
	LD	E,(IX+STRPER_X)
	LD	D,(IX+STRPER_X+1)
	LD	L,(IX+STRPER_Y)
	LD	H,(IX+STRPER_Y+1)
	LD	A,(IX+STRPER_PMV)
	LD	(LIM_COSTE_A),A

	LD	IX,NODOS
	LD	(IX+STREST_X),E
	LD	(IX+STREST_X+1),D
	LD	(IX+STREST_Y),L
	LD	(IX+STREST_Y+1),H

	PUSH	IX
	POP	DE
	LD	HL,AUX_NODOS
	PUSH	HL
	POP	IY

	XOR	A
	LD	(IX+STREST_ANT),L
	LD	(IX+STREST_ANT+1),H

	LD	(IY+STREST_ANT),A
	LD	(IY+STREST_ANT+1),A
	LD	(IY+STREST_SIG),E
	LD	(IY+STREST_SIG+1),D

	LD	HL,AUX_NODOS+STRUCTESTADO
	PUSH	HL
	POP	IY
	LD	(IY+STREST_ANT),E
	LD	(IY+STREST_ANT+1),D
	LD	(IY+STREST_SIG),A
	LD	(IY+STREST_SIG+1),A
	LD	E,-1
	LD	(IY+STREST_X),E
	LD	(IY+STREST_X+1),E
	LD	(IY+STREST_Y),E
	LD	(IY+STREST_Y+1),E
	LD	DE,$7FFE
	LD	(IY+STREST_HEURIS),E
	LD	(IY+STREST_HEURIS+1),D


	LD	(IX+STREST_SIG),L
	LD	(IX+STREST_SIG+1),H

	LD	(IX+STREST_COSTE),A
	LD	(IX+STREST_OPERA),A
	LD	(IX+STREST_PADRE),A
	LD	(IX+STREST_PADRE+1),A
	INC	A
	LD	(NUM_NODOS),A
	LD	HL,NODOS
	LD	(TAM_NODOS),HL

	CALL	GET_HEURIS
	RET



;NOMBRE: GET_BEST_A
;OBJETIVO: SE ENCARGA DE EXTRAER DE ABIERTO EL NODO CUYA FUNCION DE EVALUACION
;          SEA MENOR. EL CONJUNTO ABIERTO SE HA MODELADO MEDIANTE UNA LISTA
;          DOBLE ORDENADA (CON DOS ELEMENTOS FICTICIOS PARA MARCAR EL
;          INICIO Y EL FINAL) POR LO QUE SOLO DEBE COGER EL PRIMERO Y COLOCARLO
;          EN CERRADOS (PONER SIG Y ANT A NULL) Y COMPROBAR SI ES OBJETIVO.
;ENTRADA: (LIM_COSTE_A) -> MAXIMO VALOR DEL COSTE DEL NODO.
;SALIDA:  IY -> PUNTERO AL MEJOR NODO DE ABIERTOS
;         A -> 0 BUSQUEDA EN MARCHA
;              1 SOLUCION ENCONTRADA.
;             -1 NO HAY SOLUCION POSIBLE.

GET_BEST_A:	LD	IX,CABEZA
	LD	C,(IX)
	LD	B,(IX+1)

	PUSH	BC
	PUSH	BC
	POP	IY
	LD	E,(IY+STREST_SIG)
	LD	D,(IY+STREST_SIG+1)
	LD	(IX),E
	LD	(IX+1),D
	PUSH	DE
	POP	IY
	LD	HL,AUX_NODOS
	LD	(IY+STREST_ANT),L
	LD	(IY+STREST_ANT+1),H

	POP	IY
	XOR	A
	LD	(IY+STREST_SIG),A
	LD	(IY+STREST_SIG+1),A
	LD	(IY+STREST_ANT),A
	LD	(IY+STREST_ANT+1),A

	LD	A,(LIM_COSTE_A)	;EL COSTE ES MAYOR QUE EL LIMITE
	LD	C,(IY+STREST_COSTE)	;POR LO QUE SE DEVUELVE QUE NO SE
	CP	C	;PUEDE ALCANZAR EL OBJETIVO
	JR	NC,GET_BEST_A1
	LD	A,-1
	RET

GET_BEST_A1	LD	L,(IY+STREST_HEURIS)	;SI EL COSTE ES IGUAL A LA
	LD	H,(IY+STREST_HEURIS+1)
	LD	B,0
	XOR	A
	OR	A
	SBC	HL,BC	;FUNCION DE EVALUACION, ENTONCES
	RET	NZ	;EL HEURISTICO ES 0 Y POR TANTO
	INC	A	;ES EL OBJETIVO
	RET




LIM_COSTE_A:	DB	0

;NOMBRE: GEN_HIJOS
;OBJETIVO: SE ENCARGA DE GENERAR TODOS LOS POSIBLES DESCENDIENTES DE UN
;          NODO, ASI COMO DE EVALUARLOS Y COLOCARLOS EN LA POSICION
;          CORRESPONDIENTE EN LA LISTA ABIERTOS, Y ENCASO DE HABER SIDO
;          GENERADO CON ANTERIORIDAD REALIZAR LAS ACCIONES CORRESPONDIENTES
;          SEGUN SEA EL CASO.
;ENTRADA: IY -> NODO ORIGEN

GEN_HIJOS:	LD	HL,INSERT+STREST_PADRE
	PUSH IY
	POP  DE
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	(GEN_HIJOSP),IY


	LD	HL,GH_DELTAXI
	LD	DE,GH_DELTAYI
	LD	A,(MODO_GAME)
	LD	B,4
	LD	C,0
	CP	EXTERIOR
	JR	NZ,GEN_HIJOS1
	LD	HL,GH_DELTAXE
	LD	DE,GH_DELTAYE

GEN_HIJOS1	PUSH	BC

	LD	IX,INSERT
	LD	A,C
	EXX
	LD	HL,GH_OPERADOR
	LD	E,A
	LD	D,0
	ADD	HL,DE
	LD	A,(HL)
	LD	(IX+STREST_OPERA),A
	EXX

	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	INC	HL
	PUSH	HL
	LD	L,(IY+STREST_X)
	LD	H,(IY+STREST_X+1)
	ADD	HL,BC
	LD	(IX+STREST_X),L
	LD	(IX+STREST_X+1),H

	EX	DE,HL
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	INC	HL
	PUSH	HL
	LD	L,(IY+STREST_Y)
	LD	H,(IY+STREST_Y+1)
	ADD	HL,BC
	LD	(IX+STREST_Y),L
	LD	(IX+STREST_Y+1),H


	LD	E,(IY+STREST_PADRE)	;AHORA COMPROBAMOS QUE NO
	LD	D,(IY+STREST_PADRE+1)	;SE HA GENERADO EL ABUELO
	PUSH	DE	;AUNQUE HAY QUE COMPROBAR EL
	POP	IY	;CASO DE NO TENER ABUELO

	XOR	A
	CP	E
	JR	NZ,GEN_HIJOS3
	CP	D
	JR	Z,GEN_HIJOS4

GEN_HIJOS3	LD	A,(IX+STREST_X)
	CP	(IY+STREST_X)
	JR	NZ,GEN_HIJOS4
	LD	A,(IX+STREST_X+1)
	CP	(IY+STREST_X+1)
	JR	NZ,GEN_HIJOS4
	LD	A,(IX+STREST_Y)
	CP	(IY+STREST_Y)
	JR	NZ,GEN_HIJOS4
	LD	A,(IX+STREST_Y+1)
	CP	(IY+STREST_Y+1)
	JR	Z,GEN_HIJOS5

GEN_HIJOS4	LD	IX,INSERT
	LD	IY,(GEN_HIJOSP)
	CALL	GEST_NODO

GEN_HIJOS5	LD	IY,(GEN_HIJOSP)
	POP	DE
	POP	HL
	POP	BC
	INC	C
	DJNZ	GEN_HIJOS1
	RET


GEN_HIJOSP:	DW	0
GH_DELTAXI	DW	-8,0,8,0
GH_DELTAYI	DW	0,-8,0,8
GH_DELTAXE	DW	-32,0,32,0
GH_DELTAYE	DW	0,-16,0,16
GH_OPERADOR	DB	IZQUIERDA,ARRIBA,DERECHA,ABAJO


;NOMBRE: GEST_NODO
;OBJETIVO: SE ENCARGA DE CALCULAR EL COSTE DEL NODO,ADEMAS DE COMPROBAR
;          SI ANTES ESTABA EN ABIERTOS O EN CERRADOS, PARA LO CUAL SON
;          NECESARIAS LAS RUTINAS BUSCAR_NODO Y ANTECESOR. SI SE GENERA
;          UN NODO QUE ESTABA EN CERRADOS Y SE CAMBIA EL PADRE, ENTONCES
;          IMPLICA INTRODUCIR ESE NODO EN ABIERTOS.
;ENTRADA: IX -> NUEVO NODO GENERADO
;         IY -> NODO ORIGEN DEL NUEVO NODO
;COMENTARIOS SE SUPONE QUE ANTES DE ENTRAR EN ESTA FUNCION SE HAN ASIGNADO
;TODOS LOS VALORES CORRECTOS AL NUEVO NODO GENERADO, COMO POR EJEMPLO EL
;PADRE.



GEST_NODO:	CALL	GET_COSTE
	RET	Z
	CALL	GET_HEURIS

	PUSH	IY
	CALL	BUSCAR_NODO
	POP	IY

	LD	A,B
	OR	A
	JR	Z,GESTN_CASE1
	JR	GESTN_CASE2


;NOMBRE: GESTN_CASE1
;OBJETIVO: GESTIONAR EL CASO EN EL QUE EL NUEVO NODO NO HA SIDO GENERADO
;          CON ANTERIORIDAD.
;ENTRADA: HL -> ESTADOMAYOR
;         IX -> NUEVO

GESTN_CASE1	EXX
	LD	A,(NUM_NODOS)
	INC	A
	LD	(NUM_NODOS),A
	LD	DE,(TAM_NODOS)
	LD	HL,STRUCTESTADO
	ADD	HL,DE
	LD	(TAM_NODOS),HL

	PUSH	HL
	PUSH	HL
	EX	DE,HL
	LD	HL,INSERT
	LD	BC,STRUCTESTADO
	LDIR

	EXX
	POP	IY
	POP	BC
	PUSH	HL
	POP	IX	;HL,IX -> ESTADO_MAYOR
;                                       ;IY,BC -> AUX

GEST_CASEC	LD	E,(IX+STREST_ANT)
	LD	D,(IX+STREST_ANT+1)
	LD	(IY+STREST_ANT),E
	LD	(IY+STREST_ANT+1),D
	LD	(IY+STREST_SIG),L
	LD	(IY+STREST_SIG+1),H

	PUSH	DE
	POP	IY	;IY  -> ESTADO_MAYOR->ANT
	LD	(IY+STREST_SIG),C
	LD	(IY+STREST_SIG+1),B
	LD	(IX+STREST_ANT),C
	LD	(IX+STREST_ANT+1),B
	RET






;NOMBRE: GESTN_CASE2
;OBJETIVO: GESTIONAR EL CASO EN EL QUE EL NUEVO NODO  HA SIDO GENERADO
;          CON ANTERIORIDAD.
;ENTRADA: HL -> ESTADOMAYOR
;         IX -> NUEVO


GESTN_CASE2:	PUSH	BC
	PUSH	HL
	PUSH	IY
	CALL	ANTECESOR
	POP	IY
	POP	HL
	POP	BC
	RET	NZ
	PUSH	BC
	EXX
	POP	DE
	LD	E,D
	LD	D,0
	LD	HL,STRUCTESTADO
	CALL	MULTHLDE
	LD	DE,AUX_NODOS
	ADD	HL,DE
	PUSH	HL
	EXX
	EX	DE,HL
	POP	HL


	PUSH	IY
	POP	BC
	PUSH	HL
	POP	IY

	LD	A,(IX+STREST_COSTE)
	CP	(IY+STREST_COSTE)
	RET	Z
	RET	NC

	LD	(IY+STREST_PADRE),C
	LD	(IY+STREST_PADRE+1),B
	LD	(IY+STREST_COSTE),A


	XOR	A
	CP	(IY+STREST_SIG)
	JR	NZ,GEST_C2_ABI
	CP	(IY+STREST_SIG+1)
	JR	NZ,GEST_C2_ABI
	CP	(IY+STREST_ANT)
	JR	NZ,GEST_C2_ABI
	CP	(IY+STREST_ANT+1)
	JR	Z,GEST_C2_CER

GEST_C2_ABI	LD	E,(IY+STREST_ANT)
	LD	D,(IY+STREST_ANT+1)
	LD	C,(IY+STREST_SIG)
	LD	B,(IY+STREST_SIG+1)
	PUSH	BC
	PUSH	DE
	POP	IX
	LD	(IX+STREST_SIG),C	;ESTA EN ABIERTOS POR LO QUE ES
	LD	(IX+STREST_SIG+1),B	;NECESARIO SACARLO PARA VOLVER
	POP	IX	;A INSERTARLO
	LD	(IX+STREST_ANT),E
	LD	(IX+STREST_ANT+1),D


GEST_C2_CER	EX	DE,HL	;PODEMOS SALTAR A LA OTRA FUNCION PORQUE
	PUSH	HL	;HEMOS CONSEGUIDO LA MISMA ASIGNACION
	POP	IX	;DE VARIABLES.
	PUSH	IY
	POP	BC
	JP	GEST_CASEC



;NOMBRE: GET_COSTE
;OBJETIVO: CALCULA EL COSTE DE UN NODO A PARTIR DEL COSTE DEL PADRE. ADEMAS
;          SE ENCARGA DE COMPROBAR SI SE TIENE PERMISO DE ACCESO EN LA
;          NUEVA POSICION.
;ENTRADA: IX -> NUEVO NODO GENERADO
;         IY -> NODO ORIGEN DEL NUEVO NODO
;SALIDA:
;         Z  -> SERA 1 SI NO SE TIENE PERMISO DE ACCESO
;               Y 1 EN CASO CONTRARIO.



GET_COSTE:	LD	L,(IX+STREST_Y)
	LD	H,(IX+STREST_Y+1)
	LD	BC,PROF_PERSOM	;EN INTERIORES HABRIA QUE MODIFICAR
	ADD	HL,BC	;ESTO

	LD	A,(IY+STREST_COSTE)
	LD	C,A

	LD	B,3
GET_COSTE0	SRL	H
	RR	L
	DJNZ	GET_COSTE0

	AND	$FE
	LD	A,(ALTOPATPER)
	;              DEC     A
	INC	A
	LD	E,A
	LD	D,0
	ADD	HL,DE

	SLA	L
	RL	H

	LD	DE,INDEXMAPA
	ADD	HL,DE
	LD	E,(HL)
	INC	HL
	LD	D,(HL)

	LD	L,(IX+STREST_X)
	LD	H,(IX+STREST_X+1)
	LD	B,3
GET_COSTE1	SRL	H
	RR	L
	DJNZ	GET_COSTE1

	ADD	HL,DE
	LD	E,(HL)
	LD	D,0
	LD	HL,(PROP_PTR)
	ADD	HL,DE
	LD	A,(HL)
	BIT	0,A
	RET	Z

	EX	AF,AF'
	LD	A,(MODO_GAME)
	CP	EXTERIOR
	JR	Z,GET_COSTE_EX	;EN INTERIORES HAY QUE
	INC	C	;COMPROBAR SI SE TOMA
	LD	(IX+STREST_COSTE),C	;UN ENLACE
	RET

GET_COSTE_EX	EX	AF,AF'
	AND	$F0
	RLCA
	RLCA
	RLCA
	RLCA

	LD	HL,PROP_EXT_VEC
	LD	E,A
	LD	D,0
	ADD	HL,DE

	LD	A,(HL)	;EL COSTE VA DE 1 A 4
	AND	$C0
	RLCA
	RLCA
	INC	A
	ADD	A,C
	LD	(IX+STREST_COSTE),A


	LD	A,1	;EN EXTERIORES ADEMAS SERA
	OR	A	;NECESARIO COMPROBAR COLISIONES
	RET		;                ;CON OTROS PERSONAJES


;NOMBRE: GET_HEURIS
;OBJETIVO: CALCULAR LA FUNCION DE EVALUACION DE UN NODO. EN EXTERIORES
;          HAY QUE TENER EN CUENTA QUE EL TAMAGNO ES DE 32*16 Y EL COSTE
;          MAXIMO ES DE 4.
;ENTRADA: IX -> NUEVO NODO GENERADO

GET_HEURIS:	LD	L,(IX+STREST_X)	;MODIFICAR
	LD	H,(IX+STREST_X+1)
	LD	DE,(A_EST_XF)
	OR	A
	SBC	HL,DE
	BIT	7,H
	JR	Z,GET_HEUX1
	LD	A,L
	CPL
	LD	L,A
	LD	A,H
	CPL
	LD	H,A
	INC	HL

GET_HEUX1	LD	B,3
GET_HEUX2	SRL	H
	RR	L
	DJNZ	GET_HEUX2


GET_HEU1	EX	DE,HL
	LD	L,(IX+STREST_Y)
	LD	H,(IX+STREST_Y+1)
	LD	BC,(A_EST_YF)
	OR	A
	SBC	HL,BC
	BIT	7,H
	JR	Z,GET_HEUY1
	LD	A,L
	CPL
	LD	L,A
	LD	A,H
	CPL
	LD	H,A
	INC	HL

GET_HEUY1	LD	A,(MODO_GAME)
	LD	B,2
	CP	INTERIOR
	JR	NZ,GET_HEUY2
	LD	B,3
GET_HEUY2	SRL	H
	RR	L
	DJNZ	GET_HEUY2

	ADD	HL,DE
	LD	E,(IX+STREST_COSTE)
	LD	D,0
	ADD	HL,DE
	LD	(IX+STREST_HEURIS),L
	LD	(IX+STREST_HEURIS+1),H
	RET


;NOMBRE: BUSCAR_NODO
;OBJETIVO: SE ENCARGA DE COMPROBAR SI UN NODO SE ENCUANTRA YA GENERADO Y
;          EN CASO DE HABER SIDO GENERADO ANTES COMPRUEBA SI ESTA EN ABIERTOS
;          O EN CERRADOS. A LA VEZ QUE REALIZA LA BUSQUEDA SE VA LOCALIZANDO
;          EL ESTADO DELANTE DEL CUAL SE DEBE INSERTAR EL ESTADO GENERADO.
;ENTRADA:  IX -> NODO QUE SE QUIERE INSERTAR EN ESTA ITERACION
;DEVUELVE: B  -> SI ES 0 INDICA QUE EL NODO NO HA SIDO GENERADO CON
;                ANTERIORIDAD. EN CASO CONTRARIO INDICA LA POSICION DEL
;                NODO DENTRO DEL VECTOR AUX_NODOS
;          E  -> INDICA EL MENOR MAYOR DE ABIERTOS. EN CASO DE NO HABER
;                NINGUN MAYOR VALE 255.
;          HL -> APUNTA AL NODO DE ABIERTOS DELANTE DEL CUAL SE DEBE
;                INSERTAR EL NUEVO NODO
;MODIFICA: AF,BC,E,HL
;HAY QUE INTENTAR QUE INSERTA SIEMPRE AL FINAL DE LOS IGUALES, ASI LAS
;SOLUCIONES IGUALES SE EXPLORAN EN PROFUNDIDAD.



BUSCAR_NODO:	LD	B,1
	LD	C,0
	LD	A,(NUM_NODOS)
	INC	A
	INC	A
	LD	(BUSCAR_N_NUM),A
	LD	IY,NODOS-STRUCTESTADO	;ES NECESARIO COMPROBAR
	LD	HL,NODOS	;EL ESTADO FICTICIO QUE
	LD	DE,$7FFF	;CIERRA LA LISTA (COSTE = MAXIMO POSITIVO)

BUCLE_BUSQ	LD	A,(BUSCAR_N_NUM)
	CP	B
	JR	NZ,BUSCAR_CONT
	LD	B,C	;SE HA LLEGADO AL FINAL DEL VECTOR
	RET		;                ;Y NO SE HA ENCONTRADO EL ELEMENTO



BUSCAR_CONT	LD	A,(IY+STREST_X)
	CP	(IX+STREST_X)
	JR	NZ,BUSCAR_NO
	LD	A,(IY+STREST_X+1)
	CP	(IX+STREST_X+1)
	JR	NZ,BUSCAR_NO

	LD	A,(IY+STREST_Y)	;SI EL IDENTIFICADOR DE ESTADO
	CP	(IX+STREST_Y)	;QUE SON LAS COORDENADAS COINCIDE
	JR	NZ,BUSCAR_NO	;ENTONCES EL NODO YA HA SIDO GENERADO
	LD	A,(IY+STREST_Y+1)	;CON ANTERIORRIDAD
	CP	(IX+STREST_Y+1)	;PERO DEBO SEGUIR BUSCANDO POR
	JR	NZ,BUSCAR_NO	;SI HAY QUE INSERTAR DE NUEVO
	LD	C,B

BUSCAR_NO	XOR	A	;BUSCO EL MENORNODO QUE SEA MAYOR QUE
	CP	(IY+STREST_SIG)	;EL NOCDO QUE QUIERO INSERTAR Y QUE
	JR	NZ,BUSCAR_MENOR	;ESTA EN ABIERTOS, ES DECIR TIENE
	CP	(IY+STREST_SIG+1)	;AMBOS PUNTEROS A UN VALOR DISTINTO DE 0
	JR	NZ,BUSCAR_MENOR
	CP	(IY+STREST_ANT)
	JR	NZ,BUSCAR_MENOR
	CP	(IY+STREST_ANT+1)
	JR	Z,BUSCAR_INC2

BUSCAR_MENOR	PUSH	HL
	PUSH	BC
	LD	C,(IY+STREST_HEURIS)
	LD	B,(IY+STREST_HEURIS+1)
	LD	L,(IX+STREST_HEURIS)
	LD	H,(IX+STREST_HEURIS+1)
	OR	A
	SBC	HL,BC
	JR	NC,BUSCAR_INC1

	LD	L,E
	LD	H,D
	OR	A
	SBC	HL,BC
	JR	Z,BUSCAR_INC1
	JR	C,BUSCAR_INC1
	LD	E,C
	LD	D,B
	POP	BC
	POP	HL
	PUSH	IY
	POP	HL
	JR	BUSCAR_INC2


BUSCAR_INC1	POP	BC
	POP	HL
BUSCAR_INC2	INC	B
	PUSH	DE
	LD	DE,STRUCTESTADO
	ADD	IY,DE
	POP	DE
	JR	BUCLE_BUSQ



BUSCAR_N_NUM:	DB	0

;NOMBRE: ANTECESOR
;OBJETIVO: COMPROBAR SI UN NODO ES ANTECESOR DE OTRO DADO
;ENTRADA: IX -> PADRE
;         IY -> HIJO
;SALIDA: A -> 0 SI NO ES EL PADRE
;        A -> 1 SI ES EL PADRE
;        Z -> 0 SI NO ES EL PADRE
;        Z -> 1 SI ES EL PADRE
;MODIFICA: AF,DE,HL,IY


ANTECESOR:	XOR	A

ANTECESOR1	LD	E,(IY+STREST_PADRE)
	LD	D,(IY+STREST_PADRE+1)
	LD	HL,0
	OR	A
	SBC	HL,DE
	RET	Z

      PUSH DE
      POP IY
	LD	E,(IX+STREST_X)
	LD	D,(IX+STREST_X+1)
	LD	L,(IY+STREST_X)
	LD	H,(IY+STREST_X+1)
	OR	A
	SBC	HL,DE
	JR	NZ,ANTECESOR1

	LD	E,(IX+STREST_Y)
	LD	D,(IX+STREST_Y+1)
	LD	L,(IY+STREST_Y)
	LD	H,(IY+STREST_Y+1)
	OR	A
	SBC	HL,DE
	JR	NZ,ANTECESOR1
	LD	A,1
	OR	A
	RET

